Предложите способ сравнения двух исходных сообщений при помощи хеш
функций, чтобы выполнялись следующие условия:
1. Коллизий быть не должно (либо минимизировать их количество)
2. Должны использоваться только хеш функции и их результаты
3. Используемые хеш функции должны иметь конечное количество
значений

####тут можно проверить на работоспособность https://godbolt.org/z/a96rrdMr4 ####

Я конвектировал строку в массив ascii кодов каждого элемента.
Дополнял длинну масива до кратности 16ти (такаой длинны мне захотелось видеть ключ)
Далее рассмотривал массив как матрицу(?) у которой 16 столбцов, первую строку сразу пушил в вектор.
Далее проще привести отрывак кода, чтобы увидеть как я дальше суммировал строчки к первой 

    int offset = 15; - изза того что мы уже закинули первые 16 элементов в вектор
    if (ascii_message.size() / 16 > 1) {
        for (int i = 0; i < ascii_message.size() / 16; i++) {

            for (int j = 0; j < 16; j++) {
                hash_message[j] += ascii_message[j + offset] xor
                                   (j != 15 ? ascii_message[j + offset + 1] : ascii_message[j + offset - 2]) + adder;
                adder++;
            }
            offset += 16;
        }
    }

Далее я тусанул элементы, взял по модулю, и оставил только единицы каждого элемента
    for (int i = 0; i < 16; i++) {
        hash_message[i] += ascii_message[15 - i];

        if (hash_message[i] < 0) {
            hash_message[i] = -hash_message[i];
        }

        while (hash_message[i] >= 10) {
            hash_message[i] = hash_message[i] % 10;
        }
    }
